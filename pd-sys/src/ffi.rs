/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const CLASS_DEFAULT: u32 = 0;
pub const CLASS_PD: u32 = 1;
pub const CLASS_GOBJ: u32 = 2;
pub const CLASS_PATCHABLE: u32 = 3;
pub const CLASS_NOINLET: u32 = 8;
pub const CLASS_TYPEMASK: u32 = 3;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type FILE = _IO_FILE;
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(
        ::std::mem::size_of::<_IO_marker>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_marker))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_marker>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_marker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._sbuf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_sbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._pos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_pos)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad1 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad2 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad3 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad4 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type t_int = ::std::os::raw::c_long;
pub type t_float = f32;
pub type t_floatarg = f32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _symbol {
    pub s_name: *const ::std::os::raw::c_char,
    pub s_thing: *mut *mut _class,
    pub s_next: *mut _symbol,
}
#[test]
fn bindgen_test_layout__symbol() {
    assert_eq!(
        ::std::mem::size_of::<_symbol>(),
        24usize,
        concat!("Size of: ", stringify!(_symbol))
    );
    assert_eq!(
        ::std::mem::align_of::<_symbol>(),
        8usize,
        concat!("Alignment of ", stringify!(_symbol))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_symbol>())).s_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_symbol),
            "::",
            stringify!(s_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_symbol>())).s_thing as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_symbol),
            "::",
            stringify!(s_thing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_symbol>())).s_next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_symbol),
            "::",
            stringify!(s_next)
        )
    );
}
pub type t_symbol = _symbol;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _array {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _gstub {
    pub gs_un: _gstub__bindgen_ty_1,
    pub gs_which: ::std::os::raw::c_int,
    pub gs_refcount: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _gstub__bindgen_ty_1 {
    pub gs_glist: *mut _glist,
    pub gs_array: *mut _array,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__gstub__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_gstub__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_gstub__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_gstub__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_gstub__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gstub__bindgen_ty_1>())).gs_glist as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gstub__bindgen_ty_1),
            "::",
            stringify!(gs_glist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gstub__bindgen_ty_1>())).gs_array as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gstub__bindgen_ty_1),
            "::",
            stringify!(gs_array)
        )
    );
}
#[test]
fn bindgen_test_layout__gstub() {
    assert_eq!(
        ::std::mem::size_of::<_gstub>(),
        16usize,
        concat!("Size of: ", stringify!(_gstub))
    );
    assert_eq!(
        ::std::mem::align_of::<_gstub>(),
        8usize,
        concat!("Alignment of ", stringify!(_gstub))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gstub>())).gs_un as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gstub),
            "::",
            stringify!(gs_un)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gstub>())).gs_which as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_gstub),
            "::",
            stringify!(gs_which)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gstub>())).gs_refcount as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_gstub),
            "::",
            stringify!(gs_refcount)
        )
    );
}
pub type t_gstub = _gstub;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _gpointer {
    pub gp_un: _gpointer__bindgen_ty_1,
    pub gp_valid: ::std::os::raw::c_int,
    pub gp_stub: *mut t_gstub,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _gpointer__bindgen_ty_1 {
    pub gp_scalar: *mut _scalar,
    pub gp_w: *mut word,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__gpointer__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_gpointer__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_gpointer__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpointer__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpointer__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpointer__bindgen_ty_1>())).gp_scalar as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpointer__bindgen_ty_1),
            "::",
            stringify!(gp_scalar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpointer__bindgen_ty_1>())).gp_w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpointer__bindgen_ty_1),
            "::",
            stringify!(gp_w)
        )
    );
}
#[test]
fn bindgen_test_layout__gpointer() {
    assert_eq!(
        ::std::mem::size_of::<_gpointer>(),
        24usize,
        concat!("Size of: ", stringify!(_gpointer))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpointer>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpointer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpointer>())).gp_un as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpointer),
            "::",
            stringify!(gp_un)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpointer>())).gp_valid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpointer),
            "::",
            stringify!(gp_valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpointer>())).gp_stub as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpointer),
            "::",
            stringify!(gp_stub)
        )
    );
}
pub type t_gpointer = _gpointer;
#[repr(C)]
#[derive(Copy, Clone)]
pub union word {
    pub w_float: t_float,
    pub w_symbol: *mut t_symbol,
    pub w_gpointer: *mut t_gpointer,
    pub w_array: *mut _array,
    pub w_binbuf: *mut _binbuf,
    pub w_index: ::std::os::raw::c_int,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_word() {
    assert_eq!(
        ::std::mem::size_of::<word>(),
        8usize,
        concat!("Size of: ", stringify!(word))
    );
    assert_eq!(
        ::std::mem::align_of::<word>(),
        8usize,
        concat!("Alignment of ", stringify!(word))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<word>())).w_float as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(word),
            "::",
            stringify!(w_float)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<word>())).w_symbol as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(word),
            "::",
            stringify!(w_symbol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<word>())).w_gpointer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(word),
            "::",
            stringify!(w_gpointer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<word>())).w_array as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(word),
            "::",
            stringify!(w_array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<word>())).w_binbuf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(word),
            "::",
            stringify!(w_binbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<word>())).w_index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(word),
            "::",
            stringify!(w_index)
        )
    );
}
pub type t_word = word;
pub mod t_atomtype {
    pub type Type = u32;
    pub const A_NULL: Type = 0;
    pub const A_FLOAT: Type = 1;
    pub const A_SYMBOL: Type = 2;
    pub const A_POINTER: Type = 3;
    pub const A_SEMI: Type = 4;
    pub const A_COMMA: Type = 5;
    pub const A_DEFFLOAT: Type = 6;
    pub const A_DEFSYM: Type = 7;
    pub const A_DOLLAR: Type = 8;
    pub const A_DOLLSYM: Type = 9;
    pub const A_GIMME: Type = 10;
    pub const A_CANT: Type = 11;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _atom {
    pub a_type: t_atomtype::Type,
    pub a_w: word,
}
#[test]
fn bindgen_test_layout__atom() {
    assert_eq!(
        ::std::mem::size_of::<_atom>(),
        16usize,
        concat!("Size of: ", stringify!(_atom))
    );
    assert_eq!(
        ::std::mem::align_of::<_atom>(),
        8usize,
        concat!("Alignment of ", stringify!(_atom))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_atom>())).a_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_atom),
            "::",
            stringify!(a_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_atom>())).a_w as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_atom),
            "::",
            stringify!(a_w)
        )
    );
}
pub type t_atom = _atom;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _class {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _outlet {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _inlet {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _binbuf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _clock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glist {
    _unused: [u8; 0],
}
pub type t_pd = *mut _class;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gobj {
    pub g_pd: t_pd,
    pub g_next: *mut _gobj,
}
#[test]
fn bindgen_test_layout__gobj() {
    assert_eq!(
        ::std::mem::size_of::<_gobj>(),
        16usize,
        concat!("Size of: ", stringify!(_gobj))
    );
    assert_eq!(
        ::std::mem::align_of::<_gobj>(),
        8usize,
        concat!("Alignment of ", stringify!(_gobj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gobj>())).g_pd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gobj),
            "::",
            stringify!(g_pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gobj>())).g_next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_gobj),
            "::",
            stringify!(g_next)
        )
    );
}
pub type t_gobj = _gobj;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _scalar {
    pub sc_gobj: t_gobj,
    pub sc_template: *mut t_symbol,
    pub sc_vec: [t_word; 1usize],
}
#[test]
fn bindgen_test_layout__scalar() {
    assert_eq!(
        ::std::mem::size_of::<_scalar>(),
        32usize,
        concat!("Size of: ", stringify!(_scalar))
    );
    assert_eq!(
        ::std::mem::align_of::<_scalar>(),
        8usize,
        concat!("Alignment of ", stringify!(_scalar))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_scalar>())).sc_gobj as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_scalar),
            "::",
            stringify!(sc_gobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_scalar>())).sc_template as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_scalar),
            "::",
            stringify!(sc_template)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_scalar>())).sc_vec as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_scalar),
            "::",
            stringify!(sc_vec)
        )
    );
}
pub type t_scalar = _scalar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _text {
    pub te_g: t_gobj,
    pub te_binbuf: *mut _binbuf,
    pub te_outlet: *mut _outlet,
    pub te_inlet: *mut _inlet,
    pub te_xpix: ::std::os::raw::c_short,
    pub te_ypix: ::std::os::raw::c_short,
    pub te_width: ::std::os::raw::c_short,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u8,
}
#[test]
fn bindgen_test_layout__text() {
    assert_eq!(
        ::std::mem::size_of::<_text>(),
        48usize,
        concat!("Size of: ", stringify!(_text))
    );
    assert_eq!(
        ::std::mem::align_of::<_text>(),
        8usize,
        concat!("Alignment of ", stringify!(_text))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_text>())).te_g as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_text),
            "::",
            stringify!(te_g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_text>())).te_binbuf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_text),
            "::",
            stringify!(te_binbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_text>())).te_outlet as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_text),
            "::",
            stringify!(te_outlet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_text>())).te_inlet as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_text),
            "::",
            stringify!(te_inlet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_text>())).te_xpix as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_text),
            "::",
            stringify!(te_xpix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_text>())).te_ypix as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(_text),
            "::",
            stringify!(te_ypix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_text>())).te_width as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_text),
            "::",
            stringify!(te_width)
        )
    );
}
impl _text {
    #[inline]
    pub fn te_type(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_te_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        te_type: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let te_type: u32 = unsafe { ::std::mem::transmute(te_type) };
            te_type as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type t_object = _text;
pub type t_method = ::std::option::Option<unsafe extern "C" fn()>;
pub type t_newmethod = ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>;
extern "C" {
    pub fn pd_typedmess(
        x: *mut t_pd,
        s: *mut t_symbol,
        argc: ::std::os::raw::c_int,
        argv: *mut t_atom,
    );
}
extern "C" {
    pub fn pd_forwardmess(x: *mut t_pd, argc: ::std::os::raw::c_int, argv: *mut t_atom);
}
extern "C" {
    pub fn gensym(s: *const ::std::os::raw::c_char) -> *mut t_symbol;
}
extern "C" {
    pub fn pd_vmess(x: *mut t_pd, s: *mut t_symbol, fmt: *mut ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn obj_list(
        x: *mut t_object,
        s: *mut t_symbol,
        argc: ::std::os::raw::c_int,
        argv: *mut t_atom,
    );
}
extern "C" {
    pub fn pd_newest() -> *mut t_pd;
}
extern "C" {
    pub fn getbytes(nbytes: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn getzbytes(nbytes: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn copybytes(
        src: *const ::std::os::raw::c_void,
        nbytes: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn freebytes(x: *mut ::std::os::raw::c_void, nbytes: usize);
}
extern "C" {
    pub fn resizebytes(
        x: *mut ::std::os::raw::c_void,
        oldsize: usize,
        newsize: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn atom_getfloat(a: *const t_atom) -> t_float;
}
extern "C" {
    pub fn atom_getint(a: *const t_atom) -> t_int;
}
extern "C" {
    pub fn atom_getsymbol(a: *const t_atom) -> *mut t_symbol;
}
extern "C" {
    pub fn atom_gensym(a: *const t_atom) -> *mut t_symbol;
}
extern "C" {
    pub fn atom_getfloatarg(
        which: ::std::os::raw::c_int,
        argc: ::std::os::raw::c_int,
        argv: *const t_atom,
    ) -> t_float;
}
extern "C" {
    pub fn atom_getintarg(
        which: ::std::os::raw::c_int,
        argc: ::std::os::raw::c_int,
        argv: *const t_atom,
    ) -> t_int;
}
extern "C" {
    pub fn atom_getsymbolarg(
        which: ::std::os::raw::c_int,
        argc: ::std::os::raw::c_int,
        argv: *const t_atom,
    ) -> *mut t_symbol;
}
extern "C" {
    pub fn atom_string(
        a: *const t_atom,
        buf: *mut ::std::os::raw::c_char,
        bufsize: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn binbuf_new() -> *mut _binbuf;
}
extern "C" {
    pub fn binbuf_free(x: *mut _binbuf);
}
extern "C" {
    pub fn binbuf_duplicate(y: *const _binbuf) -> *mut _binbuf;
}
extern "C" {
    pub fn binbuf_text(x: *mut _binbuf, text: *const ::std::os::raw::c_char, size: usize);
}
extern "C" {
    pub fn binbuf_gettext(
        x: *const _binbuf,
        bufp: *mut *mut ::std::os::raw::c_char,
        lengthp: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn binbuf_clear(x: *mut _binbuf);
}
extern "C" {
    pub fn binbuf_add(x: *mut _binbuf, argc: ::std::os::raw::c_int, argv: *const t_atom);
}
extern "C" {
    pub fn binbuf_addv(x: *mut _binbuf, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn binbuf_addbinbuf(x: *mut _binbuf, y: *const _binbuf);
}
extern "C" {
    pub fn binbuf_addsemi(x: *mut _binbuf);
}
extern "C" {
    pub fn binbuf_restore(x: *mut _binbuf, argc: ::std::os::raw::c_int, argv: *const t_atom);
}
extern "C" {
    pub fn binbuf_print(x: *const _binbuf);
}
extern "C" {
    pub fn binbuf_getnatom(x: *const _binbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn binbuf_getvec(x: *const _binbuf) -> *mut t_atom;
}
extern "C" {
    pub fn binbuf_resize(x: *mut _binbuf, newsize: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn binbuf_eval(
        x: *const _binbuf,
        target: *mut t_pd,
        argc: ::std::os::raw::c_int,
        argv: *const t_atom,
    );
}
extern "C" {
    pub fn binbuf_read(
        b: *mut _binbuf,
        filename: *const ::std::os::raw::c_char,
        dirname: *const ::std::os::raw::c_char,
        crflag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn binbuf_read_via_canvas(
        b: *mut _binbuf,
        filename: *const ::std::os::raw::c_char,
        canvas: *const _glist,
        crflag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn binbuf_read_via_path(
        b: *mut _binbuf,
        filename: *const ::std::os::raw::c_char,
        dirname: *const ::std::os::raw::c_char,
        crflag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn binbuf_write(
        x: *const _binbuf,
        filename: *const ::std::os::raw::c_char,
        dir: *const ::std::os::raw::c_char,
        crflag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn binbuf_evalfile(name: *mut t_symbol, dir: *mut t_symbol);
}
extern "C" {
    pub fn binbuf_realizedollsym(
        s: *mut t_symbol,
        ac: ::std::os::raw::c_int,
        av: *const t_atom,
        tonew: ::std::os::raw::c_int,
    ) -> *mut t_symbol;
}
extern "C" {
    pub fn clock_new(owner: *mut ::std::os::raw::c_void, fn_: t_method) -> *mut _clock;
}
extern "C" {
    pub fn clock_set(x: *mut _clock, systime: f64);
}
extern "C" {
    pub fn clock_delay(x: *mut _clock, delaytime: f64);
}
extern "C" {
    pub fn clock_unset(x: *mut _clock);
}
extern "C" {
    pub fn clock_setunit(x: *mut _clock, timeunit: f64, sampflag: ::std::os::raw::c_int);
}
extern "C" {
    pub fn clock_getlogicaltime() -> f64;
}
extern "C" {
    pub fn clock_getsystime() -> f64;
}
extern "C" {
    pub fn clock_gettimesince(prevsystime: f64) -> f64;
}
extern "C" {
    pub fn clock_gettimesincewithunits(
        prevsystime: f64,
        units: f64,
        sampflag: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    pub fn clock_getsystimeafter(delaytime: f64) -> f64;
}
extern "C" {
    pub fn clock_free(x: *mut _clock);
}
extern "C" {
    pub fn pd_new(cls: *mut _class) -> *mut t_pd;
}
extern "C" {
    pub fn pd_free(x: *mut t_pd);
}
extern "C" {
    pub fn pd_bind(x: *mut t_pd, s: *mut t_symbol);
}
extern "C" {
    pub fn pd_unbind(x: *mut t_pd, s: *mut t_symbol);
}
extern "C" {
    pub fn pd_findbyclass(s: *mut t_symbol, c: *const _class) -> *mut t_pd;
}
extern "C" {
    pub fn pd_pushsym(x: *mut t_pd);
}
extern "C" {
    pub fn pd_popsym(x: *mut t_pd);
}
extern "C" {
    pub fn pd_bang(x: *mut t_pd);
}
extern "C" {
    pub fn pd_pointer(x: *mut t_pd, gp: *mut t_gpointer);
}
extern "C" {
    pub fn pd_float(x: *mut t_pd, f: t_float);
}
extern "C" {
    pub fn pd_symbol(x: *mut t_pd, s: *mut t_symbol);
}
extern "C" {
    pub fn pd_list(x: *mut t_pd, s: *mut t_symbol, argc: ::std::os::raw::c_int, argv: *mut t_atom);
}
extern "C" {
    pub fn pd_anything(
        x: *mut t_pd,
        s: *mut t_symbol,
        argc: ::std::os::raw::c_int,
        argv: *mut t_atom,
    );
}
extern "C" {
    pub fn gpointer_init(gp: *mut t_gpointer);
}
extern "C" {
    pub fn gpointer_copy(gpfrom: *const t_gpointer, gpto: *mut t_gpointer);
}
extern "C" {
    pub fn gpointer_unset(gp: *mut t_gpointer);
}
extern "C" {
    pub fn gpointer_check(
        gp: *const t_gpointer,
        headok: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inlet_new(
        owner: *mut t_object,
        dest: *mut t_pd,
        s1: *mut t_symbol,
        s2: *mut t_symbol,
    ) -> *mut _inlet;
}
extern "C" {
    pub fn pointerinlet_new(owner: *mut t_object, gp: *mut t_gpointer) -> *mut _inlet;
}
extern "C" {
    pub fn floatinlet_new(owner: *mut t_object, fp: *mut t_float) -> *mut _inlet;
}
extern "C" {
    pub fn symbolinlet_new(owner: *mut t_object, sp: *mut *mut t_symbol) -> *mut _inlet;
}
extern "C" {
    pub fn signalinlet_new(owner: *mut t_object, f: t_float) -> *mut _inlet;
}
extern "C" {
    pub fn inlet_free(x: *mut _inlet);
}
extern "C" {
    pub fn outlet_new(owner: *mut t_object, s: *mut t_symbol) -> *mut _outlet;
}
extern "C" {
    pub fn outlet_bang(x: *mut _outlet);
}
extern "C" {
    pub fn outlet_pointer(x: *mut _outlet, gp: *mut t_gpointer);
}
extern "C" {
    pub fn outlet_float(x: *mut _outlet, f: t_float);
}
extern "C" {
    pub fn outlet_symbol(x: *mut _outlet, s: *mut t_symbol);
}
extern "C" {
    pub fn outlet_list(
        x: *mut _outlet,
        s: *mut t_symbol,
        argc: ::std::os::raw::c_int,
        argv: *mut t_atom,
    );
}
extern "C" {
    pub fn outlet_anything(
        x: *mut _outlet,
        s: *mut t_symbol,
        argc: ::std::os::raw::c_int,
        argv: *mut t_atom,
    );
}
extern "C" {
    pub fn outlet_getsymbol(x: *mut _outlet) -> *mut t_symbol;
}
extern "C" {
    pub fn outlet_free(x: *mut _outlet);
}
extern "C" {
    pub fn pd_checkobject(x: *mut t_pd) -> *mut t_object;
}
extern "C" {
    pub fn glob_setfilename(
        dummy: *mut ::std::os::raw::c_void,
        name: *mut t_symbol,
        dir: *mut t_symbol,
    );
}
extern "C" {
    pub fn canvas_setargs(argc: ::std::os::raw::c_int, argv: *const t_atom);
}
extern "C" {
    pub fn canvas_getargs(argcp: *mut ::std::os::raw::c_int, argvp: *mut *mut t_atom);
}
extern "C" {
    pub fn canvas_getcurrentdir() -> *mut t_symbol;
}
extern "C" {
    pub fn canvas_getcurrent() -> *mut _glist;
}
extern "C" {
    pub fn canvas_makefilename(
        c: *const _glist,
        file: *const ::std::os::raw::c_char,
        result: *mut ::std::os::raw::c_char,
        resultsize: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn canvas_getdir(x: *const _glist) -> *mut t_symbol;
}
extern "C" {
    pub fn sys_hostfontsize(
        fontsize: ::std::os::raw::c_int,
        zoom: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sys_zoomfontwidth(
        fontsize: ::std::os::raw::c_int,
        zoom: ::std::os::raw::c_int,
        worstcase: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sys_zoomfontheight(
        fontsize: ::std::os::raw::c_int,
        zoom: ::std::os::raw::c_int,
        worstcase: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sys_fontwidth(fontsize: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sys_fontheight(fontsize: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn canvas_dataproperties(x: *mut _glist, sc: *mut t_scalar, b: *mut _binbuf);
}
extern "C" {
    pub fn canvas_open(
        x: *const _glist,
        name: *const ::std::os::raw::c_char,
        ext: *const ::std::os::raw::c_char,
        dirresult: *mut ::std::os::raw::c_char,
        nameresult: *mut *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
        bin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _widgetbehavior {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _parentwidgetbehavior {
    _unused: [u8; 0],
}
extern "C" {
    pub fn pd_getparentwidget(x: *mut t_pd) -> *const _parentwidgetbehavior;
}
extern "C" {
    pub fn class_new(
        name: *mut t_symbol,
        newmethod: t_newmethod,
        freemethod: t_method,
        size: usize,
        flags: ::std::os::raw::c_int,
        arg1: t_atomtype::Type,
        ...
    ) -> *mut _class;
}
extern "C" {
    pub fn class_new64(
        name: *mut t_symbol,
        newmethod: t_newmethod,
        freemethod: t_method,
        size: usize,
        flags: ::std::os::raw::c_int,
        arg1: t_atomtype::Type,
        ...
    ) -> *mut _class;
}
extern "C" {
    pub fn class_addcreator(newmethod: t_newmethod, s: *mut t_symbol, type1: t_atomtype::Type, ...);
}
extern "C" {
    pub fn class_addmethod(
        c: *mut _class,
        fn_: t_method,
        sel: *mut t_symbol,
        arg1: t_atomtype::Type,
        ...
    );
}
extern "C" {
    pub fn class_addbang(c: *mut _class, fn_: t_method);
}
extern "C" {
    pub fn class_addpointer(c: *mut _class, fn_: t_method);
}
extern "C" {
    pub fn class_doaddfloat(c: *mut _class, fn_: t_method);
}
extern "C" {
    pub fn class_addsymbol(c: *mut _class, fn_: t_method);
}
extern "C" {
    pub fn class_addlist(c: *mut _class, fn_: t_method);
}
extern "C" {
    pub fn class_addanything(c: *mut _class, fn_: t_method);
}
extern "C" {
    pub fn class_sethelpsymbol(c: *mut _class, s: *mut t_symbol);
}
extern "C" {
    pub fn class_setwidget(c: *mut _class, w: *const _widgetbehavior);
}
extern "C" {
    pub fn class_setparentwidget(c: *mut _class, w: *const _parentwidgetbehavior);
}
extern "C" {
    pub fn class_getname(c: *const _class) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn class_gethelpname(c: *const _class) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn class_gethelpdir(c: *const _class) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn class_setdrawcommand(c: *mut _class);
}
extern "C" {
    pub fn class_isdrawcommand(c: *const _class) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn class_domainsignalin(c: *mut _class, onset: ::std::os::raw::c_int);
}
extern "C" {
    pub fn class_set_extern_dir(s: *mut t_symbol);
}
pub type t_savefn = ::std::option::Option<unsafe extern "C" fn(x: *mut t_gobj, b: *mut _binbuf)>;
extern "C" {
    pub fn class_setsavefn(c: *mut _class, f: t_savefn);
}
extern "C" {
    pub fn class_getsavefn(c: *const _class) -> t_savefn;
}
extern "C" {
    pub fn obj_saveformat(x: *const t_object, bb: *mut _binbuf);
}
pub type t_propertiesfn =
    ::std::option::Option<unsafe extern "C" fn(x: *mut t_gobj, glist: *mut _glist)>;
extern "C" {
    pub fn class_setpropertiesfn(c: *mut _class, f: t_propertiesfn);
}
extern "C" {
    pub fn class_getpropertiesfn(c: *const _class) -> t_propertiesfn;
}
extern "C" {
    pub fn post(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn startpost(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn poststring(s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn postfloat(f: t_floatarg);
}
extern "C" {
    pub fn postatom(argc: ::std::os::raw::c_int, argv: *const t_atom);
}
extern "C" {
    pub fn endpost();
}
extern "C" {
    pub fn error(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn verbose(level: ::std::os::raw::c_int, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn bug(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn pd_error(object: *const ::std::os::raw::c_void, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn logpost(
        object: *const ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn sys_logerror(object: *const ::std::os::raw::c_char, s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sys_unixerror(object: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sys_ouch();
}
extern "C" {
    pub fn sys_isabsolutepath(dir: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sys_bashfilename(from: *const ::std::os::raw::c_char, to: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn sys_unbashfilename(from: *const ::std::os::raw::c_char, to: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn sys_getrealtime() -> f64;
}
extern "C" {
    pub fn sys_open(
        path: *const ::std::os::raw::c_char,
        oflag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sys_close(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sys_fopen(
        filename: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn sys_fclose(stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sys_lock();
}
extern "C" {
    pub fn sys_unlock();
}
extern "C" {
    pub fn sys_trylock() -> ::std::os::raw::c_int;
}
pub type t_sample = f32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _signal {
    pub s_n: ::std::os::raw::c_int,
    pub s_vec: *mut t_sample,
    pub s_sr: t_float,
    pub s_refcount: ::std::os::raw::c_int,
    pub s_isborrowed: ::std::os::raw::c_int,
    pub s_borrowedfrom: *mut _signal,
    pub s_nextfree: *mut _signal,
    pub s_nextused: *mut _signal,
    pub s_vecsize: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__signal() {
    assert_eq!(
        ::std::mem::size_of::<_signal>(),
        64usize,
        concat!("Size of: ", stringify!(_signal))
    );
    assert_eq!(
        ::std::mem::align_of::<_signal>(),
        8usize,
        concat!("Alignment of ", stringify!(_signal))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_signal>())).s_n as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_signal),
            "::",
            stringify!(s_n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_signal>())).s_vec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_signal),
            "::",
            stringify!(s_vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_signal>())).s_sr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_signal),
            "::",
            stringify!(s_sr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_signal>())).s_refcount as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_signal),
            "::",
            stringify!(s_refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_signal>())).s_isborrowed as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_signal),
            "::",
            stringify!(s_isborrowed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_signal>())).s_borrowedfrom as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_signal),
            "::",
            stringify!(s_borrowedfrom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_signal>())).s_nextfree as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_signal),
            "::",
            stringify!(s_nextfree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_signal>())).s_nextused as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_signal),
            "::",
            stringify!(s_nextused)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_signal>())).s_vecsize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_signal),
            "::",
            stringify!(s_vecsize)
        )
    );
}
pub type t_signal = _signal;
pub type t_perfroutine =
    ::std::option::Option<unsafe extern "C" fn(args: *mut t_int) -> *mut t_int>;
extern "C" {
    pub fn plus_perform(args: *mut t_int) -> *mut t_int;
}
extern "C" {
    pub fn zero_perform(args: *mut t_int) -> *mut t_int;
}
extern "C" {
    pub fn copy_perform(args: *mut t_int) -> *mut t_int;
}
extern "C" {
    pub fn dsp_add_plus(
        in1: *mut t_sample,
        in2: *mut t_sample,
        out: *mut t_sample,
        n: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn dsp_add_copy(in_: *mut t_sample, out: *mut t_sample, n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn dsp_add_scalarcopy(in_: *mut t_float, out: *mut t_sample, n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn dsp_add_zero(out: *mut t_sample, n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn sys_getblksize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sys_getsr() -> t_float;
}
extern "C" {
    pub fn sys_get_inchannels() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sys_get_outchannels() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dsp_add(f: t_perfroutine, n: ::std::os::raw::c_int, ...);
}
extern "C" {
    pub fn dsp_addv(f: t_perfroutine, n: ::std::os::raw::c_int, vec: *mut t_int);
}
extern "C" {
    pub fn pd_fft(
        buf: *mut t_float,
        npoints: ::std::os::raw::c_int,
        inverse: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ilog2(n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mayer_fht(fz: *mut t_sample, n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn mayer_fft(n: ::std::os::raw::c_int, real: *mut t_sample, imag: *mut t_sample);
}
extern "C" {
    pub fn mayer_ifft(n: ::std::os::raw::c_int, real: *mut t_sample, imag: *mut t_sample);
}
extern "C" {
    pub fn mayer_realfft(n: ::std::os::raw::c_int, real: *mut t_sample);
}
extern "C" {
    pub fn mayer_realifft(n: ::std::os::raw::c_int, real: *mut t_sample);
}
extern "C" {
    pub fn canvas_suspend_dsp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn canvas_resume_dsp(oldstate: ::std::os::raw::c_int);
}
extern "C" {
    pub fn canvas_update_dsp();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _resample {
    pub method: ::std::os::raw::c_int,
    pub downsample: ::std::os::raw::c_int,
    pub upsample: ::std::os::raw::c_int,
    pub s_vec: *mut t_sample,
    pub s_n: ::std::os::raw::c_int,
    pub coeffs: *mut t_sample,
    pub coefsize: ::std::os::raw::c_int,
    pub buffer: *mut t_sample,
    pub bufsize: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__resample() {
    assert_eq!(
        ::std::mem::size_of::<_resample>(),
        64usize,
        concat!("Size of: ", stringify!(_resample))
    );
    assert_eq!(
        ::std::mem::align_of::<_resample>(),
        8usize,
        concat!("Alignment of ", stringify!(_resample))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_resample>())).method as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_resample),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_resample>())).downsample as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_resample),
            "::",
            stringify!(downsample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_resample>())).upsample as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_resample),
            "::",
            stringify!(upsample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_resample>())).s_vec as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_resample),
            "::",
            stringify!(s_vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_resample>())).s_n as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_resample),
            "::",
            stringify!(s_n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_resample>())).coeffs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_resample),
            "::",
            stringify!(coeffs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_resample>())).coefsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_resample),
            "::",
            stringify!(coefsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_resample>())).buffer as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_resample),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_resample>())).bufsize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_resample),
            "::",
            stringify!(bufsize)
        )
    );
}
pub type t_resample = _resample;
extern "C" {
    pub fn resample_init(x: *mut t_resample);
}
extern "C" {
    pub fn resample_free(x: *mut t_resample);
}
extern "C" {
    pub fn resample_dsp(
        x: *mut t_resample,
        in_: *mut t_sample,
        insize: ::std::os::raw::c_int,
        out: *mut t_sample,
        outsize: ::std::os::raw::c_int,
        method: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn resamplefrom_dsp(
        x: *mut t_resample,
        in_: *mut t_sample,
        insize: ::std::os::raw::c_int,
        outsize: ::std::os::raw::c_int,
        method: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn resampleto_dsp(
        x: *mut t_resample,
        out: *mut t_sample,
        insize: ::std::os::raw::c_int,
        outsize: ::std::os::raw::c_int,
        method: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _garray {
    _unused: [u8; 0],
}
extern "C" {
    pub fn garray_getfloatarray(
        x: *mut _garray,
        size: *mut ::std::os::raw::c_int,
        vec: *mut *mut t_float,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn garray_getfloatwords(
        x: *mut _garray,
        size: *mut ::std::os::raw::c_int,
        vec: *mut *mut t_word,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn garray_redraw(x: *mut _garray);
}
extern "C" {
    pub fn garray_npoints(x: *mut _garray) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn garray_vec(x: *mut _garray) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn garray_resize(x: *mut _garray, f: t_floatarg);
}
extern "C" {
    pub fn garray_resize_long(x: *mut _garray, n: ::std::os::raw::c_long);
}
extern "C" {
    pub fn garray_usedindsp(x: *mut _garray);
}
extern "C" {
    pub fn garray_setsaveit(x: *mut _garray, saveit: ::std::os::raw::c_int);
}
extern "C" {
    pub fn garray_getglist(x: *mut _garray) -> *mut _glist;
}
extern "C" {
    pub fn garray_getarray(x: *mut _garray) -> *mut _array;
}
extern "C" {
    pub fn value_get(s: *mut t_symbol) -> *mut t_float;
}
extern "C" {
    pub fn value_release(s: *mut t_symbol);
}
extern "C" {
    pub fn value_getfloat(s: *mut t_symbol, f: *mut t_float) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn value_setfloat(s: *mut t_symbol, f: t_float) -> ::std::os::raw::c_int;
}
pub type t_guicallbackfn =
    ::std::option::Option<unsafe extern "C" fn(client: *mut t_gobj, glist: *mut _glist)>;
extern "C" {
    pub fn sys_vgui(fmt: *mut ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn sys_gui(s: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn sys_pretendguibytes(n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn sys_queuegui(
        client: *mut ::std::os::raw::c_void,
        glist: *mut _glist,
        f: t_guicallbackfn,
    );
}
extern "C" {
    pub fn sys_unqueuegui(client: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn sys_getversion(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        bugfix: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub static mut s_pointer: t_symbol;
}
extern "C" {
    pub static mut s_float: t_symbol;
}
extern "C" {
    pub static mut s_symbol: t_symbol;
}
extern "C" {
    pub static mut s_bang: t_symbol;
}
extern "C" {
    pub static mut s_list: t_symbol;
}
extern "C" {
    pub static mut s_anything: t_symbol;
}
extern "C" {
    pub static mut s_signal: t_symbol;
}
extern "C" {
    pub static mut s__N: t_symbol;
}
extern "C" {
    pub static mut s__X: t_symbol;
}
extern "C" {
    pub static mut s_x: t_symbol;
}
extern "C" {
    pub static mut s_y: t_symbol;
}
extern "C" {
    pub static mut s_: t_symbol;
}
extern "C" {
    pub fn pd_getcanvaslist() -> *mut _glist;
}
extern "C" {
    pub fn pd_getdspstate() -> ::std::os::raw::c_int;
}
